//
// Generated file, do not edit! Created by opp_msgc 4.5 from simCore/messages.msg.
//

#ifndef _MESSAGES_M_H_
#define _MESSAGES_M_H_

#include <omnetpp.h>

// opp_msgc version check
#define MSGC_VERSION 0x0405
#if (MSGC_VERSION!=OMNETPP_VERSION)
#    error Version mismatch! Probably this file was generated by an earlier version of opp_msgc: 'make clean' should help.
#endif



/**
 * Enum generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * enum PSE_STATE
 * {
 * 
 *     PSE_OFF = 0;
 *     PSE_ON = 1;
 * }
 * </pre>
 */
enum PSE_STATE {
    PSE_OFF = 0,
    PSE_ON = 1
};

/**
 * Enum generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * enum ElectronicMessageTypes
 * {
 * 
 *     dataPacket = 0;
 * 
 *     pathSetup = 1;
 *     pathTeardown = 2;
 *     pathBlocked = 3;
 *     pathACK = 4;
 *     
 *     pathRespond = 5; 
 * 
 * 
 *     pathUnknown = 8;
 *     
 *     pathBlockedTurnaround = 9;
 *     pathSetupCancelled = 10;
 *     
 *     router_bufferAck = 20;
 *     
 *     grantDataTx = 21;
 *     requestDataTx = 22;
 *     
 *     
 *     
 *     router_unblock = 101;
 *  	router_xbar = 102; 
 *  	router_arb_req = 103;
 *  	router_arb_grant = 104;
 *  	router_arb_deny = 105;  
 *  	router_arb_unblock = 106;
 *  	router_pse_setup = 107;
 *  	router_change_blocked = 108;
 *  	router_change_cancel = 109;
 *  	router_arb_escape = 110;
 *  	
 *  	router_power_arbiter = 111;
 *  	router_power_crossbar = 112;
 *  	router_power_inport = 113;
 *  	
 *  	router_grant_destroy = 114;
 *  	
 *     proc_req_send = 200;
 *  	proc_grant = 201;
 *  	proc_data = 202;
 *  	proc_msg_sent = 203;  
 *  	
 *  	 
 * 
 *  	router_partial_blocked = 301;
 *  	
 *  	collision_detected_TX = 400;
 *  	collision_detected_RX = 401;
 *  	medium_free = 402;
 *  	medium_occupied = 403;
 *  	transmission_OK = 404;
 *  	
 *  	token = 500;
 *  	wireless_ACK = 501;
 *  	wireless_NACK = 502;
 *  	broadcast_NACK = 503;
 *  	
 *  	startNACKperiod = 550;
 *  	stopNACKperiod = 551;
 * }
 * </pre>
 */
enum ElectronicMessageTypes {
    dataPacket = 0,
    pathSetup = 1,
    pathTeardown = 2,
    pathBlocked = 3,
    pathACK = 4,
    pathRespond = 5,
    pathUnknown = 8,
    pathBlockedTurnaround = 9,
    pathSetupCancelled = 10,
    router_bufferAck = 20,
    grantDataTx = 21,
    requestDataTx = 22,
    router_unblock = 101,
    router_xbar = 102,
    router_arb_req = 103,
    router_arb_grant = 104,
    router_arb_deny = 105,
    router_arb_unblock = 106,
    router_pse_setup = 107,
    router_change_blocked = 108,
    router_change_cancel = 109,
    router_arb_escape = 110,
    router_power_arbiter = 111,
    router_power_crossbar = 112,
    router_power_inport = 113,
    router_grant_destroy = 114,
    proc_req_send = 200,
    proc_grant = 201,
    proc_data = 202,
    proc_msg_sent = 203,
    router_partial_blocked = 301,
    collision_detected_TX = 400,
    collision_detected_RX = 401,
    medium_free = 402,
    medium_occupied = 403,
    transmission_OK = 404,
    token = 500,
    wireless_ACK = 501,
    wireless_NACK = 502,
    broadcast_NACK = 503,
    startNACKperiod = 550,
    stopNACKperiod = 551
};

/**
 * Enum generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * enum ProcessorCntrlTypes {
 *  
 *     
 * }
 * </pre>
 */
enum ProcessorCntrlTypes {
};

/**
 * Enum generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * enum PhotonicMessageTypes
 * {
 *     TXstart = 1;
 *     TXstop = 2;
 *     Llevel = 3;
 *     Nstart = 5;
 *     Nstop = 6;
 *     VTXstart = 7;
 * 	VTXstop = 8;
 * 	TXpulse = 9;
 * }
 * </pre>
 */
enum PhotonicMessageTypes {
    TXstart = 1,
    TXstop = 2,
    Llevel = 3,
    Nstart = 5,
    Nstop = 6,
    VTXstart = 7,
    VTXstop = 8,
    TXpulse = 9
};

/**
 * Enum generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * enum ProcMsgType {
 *     
 *     
 *     
 *     SM_read = 0;
 *     SM_write = 1;
 *     
 *     
 *     DM_readLocal = 10;
 *     DM_readRemote = 11;
 *     DM_writeLocal = 12;
 *     DM_writeRemote = 13;
 *     
 *     M_readResponse = 1000;
 *     
 *     
 *     MPI_send = 20;
 *     
 *     
 *     CPU_op = 50;
 *     
 *     
 *     snoopReq = 60;
 *     snoopResp = 61;
 *     
 *     
 *     hybridBlockW = 70;
 *     hybridUnblockW = 71;
 *     
 *     
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	procSynch = 100;
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 *  	
 * }
 * </pre>
 */
enum ProcMsgType {
    SM_read = 0,
    SM_write = 1,
    DM_readLocal = 10,
    DM_readRemote = 11,
    DM_writeLocal = 12,
    DM_writeRemote = 13,
    M_readResponse = 1000,
    MPI_send = 20,
    CPU_op = 50,
    snoopReq = 60,
    snoopResp = 61,
    hybridBlockW = 70,
    hybridUnblockW = 71,
    procSynch = 100
};

/**
 * Enum generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * enum DRAM_CntrlTypes {
 *  	Row_Access = 0;
 *  	Col_Access = 1;
 *  	Precharge = 2;   
 *  	Write_Data = 3;
 *     
 * }
 * </pre>
 */
enum DRAM_CntrlTypes {
    Row_Access = 0,
    Col_Access = 1,
    Precharge = 2,
    Write_Data = 3
};

/**
 * Enum generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * enum MemoryAccessType {   
 *  	MemoryIFetechCmd = 1;
 *  	MemoryWriteCmd = 2;
 *  	MemoryReadCmd = 3;
 *  	MemoryPrefetchCmd = 4;
 * }
 * </pre>
 */
enum MemoryAccessType {
    MemoryIFetechCmd = 1,
    MemoryWriteCmd = 2,
    MemoryReadCmd = 3,
    MemoryPrefetchCmd = 4
};

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet ElectronicMessage
 * {
 *    
 *     int Id;
 *     long SrcId;
 *   
 *     long DstId;
 *    
 *     
 *     int virtualChannel;
 *     
 *     int MsgType enum(ElectronicMessageTypes);
 *  
 * 	long data;
 * 	
 * 	simtime_t time;
 * 	
 * 	bool bcast = false;
 * 
 *  	int RTB = 0;	
 *  	int LTB = 0; 	
 *  	int sourceBit = 1; 
 *  	
 *  	int numRetries = 0;
 * 	int BOcounter = 0;
 * 
 *     
 *     bool circuitAvailable[];
 *     
 *     
 *     bool circuitCheck[];
 * }
 * </pre>
 */
class ElectronicMessage : public ::cPacket
{
  protected:
    int Id_var;
    long SrcId_var;
    long DstId_var;
    int virtualChannel_var;
    int MsgType_var;
    long data_var;
    simtime_t time_var;
    bool bcast_var;
    int RTB_var;
    int LTB_var;
    int sourceBit_var;
    int numRetries_var;
    int BOcounter_var;
    bool *circuitAvailable_var; // array ptr
    unsigned int circuitAvailable_arraysize;
    bool *circuitCheck_var; // array ptr
    unsigned int circuitCheck_arraysize;

  private:
    void copy(const ElectronicMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ElectronicMessage&);

  public:
    ElectronicMessage(const char *name=NULL, int kind=0);
    ElectronicMessage(const ElectronicMessage& other);
    virtual ~ElectronicMessage();
    ElectronicMessage& operator=(const ElectronicMessage& other);
    virtual ElectronicMessage *dup() const {return new ElectronicMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getId() const;
    virtual void setId(int Id);
    virtual long getSrcId() const;
    virtual void setSrcId(long SrcId);
    virtual long getDstId() const;
    virtual void setDstId(long DstId);
    virtual int getVirtualChannel() const;
    virtual void setVirtualChannel(int virtualChannel);
    virtual int getMsgType() const;
    virtual void setMsgType(int MsgType);
    virtual long getData() const;
    virtual void setData(long data);
    virtual simtime_t getTime() const;
    virtual void setTime(simtime_t time);
    virtual bool getBcast() const;
    virtual void setBcast(bool bcast);
    virtual int getRTB() const;
    virtual void setRTB(int RTB);
    virtual int getLTB() const;
    virtual void setLTB(int LTB);
    virtual int getSourceBit() const;
    virtual void setSourceBit(int sourceBit);
    virtual int getNumRetries() const;
    virtual void setNumRetries(int numRetries);
    virtual int getBOcounter() const;
    virtual void setBOcounter(int BOcounter);
    virtual void setCircuitAvailableArraySize(unsigned int size);
    virtual unsigned int getCircuitAvailableArraySize() const;
    virtual bool getCircuitAvailable(unsigned int k) const;
    virtual void setCircuitAvailable(unsigned int k, bool circuitAvailable);
    virtual void setCircuitCheckArraySize(unsigned int size);
    virtual unsigned int getCircuitCheckArraySize() const;
    virtual bool getCircuitCheck(unsigned int k) const;
    virtual void setCircuitCheck(unsigned int k, bool circuitCheck);
};

inline void doPacking(cCommBuffer *b, ElectronicMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ElectronicMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet PathSetupMsg extends ElectronicMessage {
 *     
 *  	int allowedTx;   
 *  	int dataWidth;  
 *  	
 *  	long blockedAddr; 
 * }
 * </pre>
 */
class PathSetupMsg : public ::ElectronicMessage
{
  protected:
    int allowedTx_var;
    int dataWidth_var;
    long blockedAddr_var;

  private:
    void copy(const PathSetupMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PathSetupMsg&);

  public:
    PathSetupMsg(const char *name=NULL, int kind=0);
    PathSetupMsg(const PathSetupMsg& other);
    virtual ~PathSetupMsg();
    PathSetupMsg& operator=(const PathSetupMsg& other);
    virtual PathSetupMsg *dup() const {return new PathSetupMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getAllowedTx() const;
    virtual void setAllowedTx(int allowedTx);
    virtual int getDataWidth() const;
    virtual void setDataWidth(int dataWidth);
    virtual long getBlockedAddr() const;
    virtual void setBlockedAddr(long blockedAddr);
};

inline void doPacking(cCommBuffer *b, PathSetupMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PathSetupMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet PhotonicMessage
 * {
 *     int MsgType enum(PhotonicMessageTypes);
 *     int Id;
 *   
 *   
 *    
 *     long PacketStat;
 *    
 *   
 * }
 * </pre>
 */
class PhotonicMessage : public ::cPacket
{
  protected:
    int MsgType_var;
    int Id_var;
    long PacketStat_var;

  private:
    void copy(const PhotonicMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const PhotonicMessage&);

  public:
    PhotonicMessage(const char *name=NULL, int kind=0);
    PhotonicMessage(const PhotonicMessage& other);
    virtual ~PhotonicMessage();
    PhotonicMessage& operator=(const PhotonicMessage& other);
    virtual PhotonicMessage *dup() const {return new PhotonicMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getMsgType() const;
    virtual void setMsgType(int MsgType);
    virtual int getId() const;
    virtual void setId(int Id);
    virtual long getPacketStat() const;
    virtual void setPacketStat(long PacketStat);
};

inline void doPacking(cCommBuffer *b, PhotonicMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, PhotonicMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet VWTcntrlMsg extends ElectronicMessage
 * {
 *  	int wavelengths;   
 *     
 * }
 * </pre>
 */
class VWTcntrlMsg : public ::ElectronicMessage
{
  protected:
    int wavelengths_var;

  private:
    void copy(const VWTcntrlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const VWTcntrlMsg&);

  public:
    VWTcntrlMsg(const char *name=NULL, int kind=0);
    VWTcntrlMsg(const VWTcntrlMsg& other);
    virtual ~VWTcntrlMsg();
    VWTcntrlMsg& operator=(const VWTcntrlMsg& other);
    virtual VWTcntrlMsg *dup() const {return new VWTcntrlMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getWavelengths() const;
    virtual void setWavelengths(int wavelengths);
};

inline void doPacking(cCommBuffer *b, VWTcntrlMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, VWTcntrlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet ApplicationData{
 *     int type enum (ProcMsgType);
 *     
 *     int id;
 *     int destId;
 *     int srcId;
 *     int payloadSize;
 *     long payload[];
 *     
 *     bool isComplete;
 *     
 *     simtime_t creationTime;
 *    
 * }
 * </pre>
 */
class ApplicationData : public ::cPacket
{
  protected:
    int type_var;
    int id_var;
    int destId_var;
    int srcId_var;
    int payloadSize_var;
    long *payload_var; // array ptr
    unsigned int payload_arraysize;
    bool isComplete_var;
    simtime_t creationTime_var;

  private:
    void copy(const ApplicationData& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ApplicationData&);

  public:
    ApplicationData(const char *name=NULL, int kind=0);
    ApplicationData(const ApplicationData& other);
    virtual ~ApplicationData();
    ApplicationData& operator=(const ApplicationData& other);
    virtual ApplicationData *dup() const {return new ApplicationData(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getId() const;
    virtual void setId(int id);
    virtual int getDestId() const;
    virtual void setDestId(int destId);
    virtual int getSrcId() const;
    virtual void setSrcId(int srcId);
    virtual int getPayloadSize() const;
    virtual void setPayloadSize(int payloadSize);
    virtual void setPayloadArraySize(unsigned int size);
    virtual unsigned int getPayloadArraySize() const;
    virtual long getPayload(unsigned int k) const;
    virtual void setPayload(unsigned int k, long payload);
    virtual bool getIsComplete() const;
    virtual void setIsComplete(bool isComplete);
    virtual simtime_t getCreationTime() const;
    virtual void setCreationTime(simtime_t creationTime);
};

inline void doPacking(cCommBuffer *b, ApplicationData& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ApplicationData& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet ProcessorData {
 *     
 *     int size;
 *     bool isComplete;
 *     long destAddr;
 *     long srcAddr;
 *     int type enum(ElectronicMessageTypes);
 *  
 *     int id;
 *     
 *     simtime_t creationTime = 0;
 *     simtime_t nifArriveTime = 0;
 *     simtime_t savedTime1 = 0;
 *     simtime_t savedTime2 = 0;
 *     
 *     int dataType = 0;
 *     int switchPlanes = 0;
 * }
 * </pre>
 */
class ProcessorData : public ::cPacket
{
  protected:
    int size_var;
    bool isComplete_var;
    long destAddr_var;
    long srcAddr_var;
    int type_var;
    int id_var;
    simtime_t creationTime_var;
    simtime_t nifArriveTime_var;
    simtime_t savedTime1_var;
    simtime_t savedTime2_var;
    int dataType_var;
    int switchPlanes_var;

  private:
    void copy(const ProcessorData& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ProcessorData&);

  public:
    ProcessorData(const char *name=NULL, int kind=0);
    ProcessorData(const ProcessorData& other);
    virtual ~ProcessorData();
    ProcessorData& operator=(const ProcessorData& other);
    virtual ProcessorData *dup() const {return new ProcessorData(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getSize() const;
    virtual void setSize(int size);
    virtual bool getIsComplete() const;
    virtual void setIsComplete(bool isComplete);
    virtual long getDestAddr() const;
    virtual void setDestAddr(long destAddr);
    virtual long getSrcAddr() const;
    virtual void setSrcAddr(long srcAddr);
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getId() const;
    virtual void setId(int id);
    virtual simtime_t getCreationTime() const;
    virtual void setCreationTime(simtime_t creationTime);
    virtual simtime_t getNifArriveTime() const;
    virtual void setNifArriveTime(simtime_t nifArriveTime);
    virtual simtime_t getSavedTime1() const;
    virtual void setSavedTime1(simtime_t savedTime1);
    virtual simtime_t getSavedTime2() const;
    virtual void setSavedTime2(simtime_t savedTime2);
    virtual int getDataType() const;
    virtual void setDataType(int dataType);
    virtual int getSwitchPlanes() const;
    virtual void setSwitchPlanes(int switchPlanes);
};

inline void doPacking(cCommBuffer *b, ProcessorData& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ProcessorData& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet RouterCntrlMsg {
 *  	int type enum(ElectronicMessageTypes);
 *  	long data;   
 *  	int vc;
 *  	int msgId;
 *  	int newVC;
 *  	simtime_t time;
 *  	
 *  	    
 *     bool circuitAvailable[];
 *     
 *     
 *     bool circuitCheck[];
 *     
 *     int RTB = 0;	
 *  	int LTB = 0; 	
 *  	int sourceBit = 1; 
 * 
 * }
 * </pre>
 */
class RouterCntrlMsg : public ::cPacket
{
  protected:
    int type_var;
    long data_var;
    int vc_var;
    int msgId_var;
    int newVC_var;
    simtime_t time_var;
    bool *circuitAvailable_var; // array ptr
    unsigned int circuitAvailable_arraysize;
    bool *circuitCheck_var; // array ptr
    unsigned int circuitCheck_arraysize;
    int RTB_var;
    int LTB_var;
    int sourceBit_var;

  private:
    void copy(const RouterCntrlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const RouterCntrlMsg&);

  public:
    RouterCntrlMsg(const char *name=NULL, int kind=0);
    RouterCntrlMsg(const RouterCntrlMsg& other);
    virtual ~RouterCntrlMsg();
    RouterCntrlMsg& operator=(const RouterCntrlMsg& other);
    virtual RouterCntrlMsg *dup() const {return new RouterCntrlMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
    virtual long getData() const;
    virtual void setData(long data);
    virtual int getVc() const;
    virtual void setVc(int vc);
    virtual int getMsgId() const;
    virtual void setMsgId(int msgId);
    virtual int getNewVC() const;
    virtual void setNewVC(int newVC);
    virtual simtime_t getTime() const;
    virtual void setTime(simtime_t time);
    virtual void setCircuitAvailableArraySize(unsigned int size);
    virtual unsigned int getCircuitAvailableArraySize() const;
    virtual bool getCircuitAvailable(unsigned int k) const;
    virtual void setCircuitAvailable(unsigned int k, bool circuitAvailable);
    virtual void setCircuitCheckArraySize(unsigned int size);
    virtual unsigned int getCircuitCheckArraySize() const;
    virtual bool getCircuitCheck(unsigned int k) const;
    virtual void setCircuitCheck(unsigned int k, bool circuitCheck);
    virtual int getRTB() const;
    virtual void setRTB(int RTB);
    virtual int getLTB() const;
    virtual void setLTB(int LTB);
    virtual int getSourceBit() const;
    virtual void setSourceBit(int sourceBit);
};

inline void doPacking(cCommBuffer *b, RouterCntrlMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, RouterCntrlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet DeviceCntrlMsg {
 *  	bool on;
 *  	double data;
 * }
 * </pre>
 */
class DeviceCntrlMsg : public ::cPacket
{
  protected:
    bool on_var;
    double data_var;

  private:
    void copy(const DeviceCntrlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DeviceCntrlMsg&);

  public:
    DeviceCntrlMsg(const char *name=NULL, int kind=0);
    DeviceCntrlMsg(const DeviceCntrlMsg& other);
    virtual ~DeviceCntrlMsg();
    DeviceCntrlMsg& operator=(const DeviceCntrlMsg& other);
    virtual DeviceCntrlMsg *dup() const {return new DeviceCntrlMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual bool getOn() const;
    virtual void setOn(bool on);
    virtual double getData() const;
    virtual void setData(double data);
};

inline void doPacking(cCommBuffer *b, DeviceCntrlMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DeviceCntrlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet XbarMsg extends RouterCntrlMsg {
 *  	int fromPort;
 *  	int toPort;   
 * }
 * </pre>
 */
class XbarMsg : public ::RouterCntrlMsg
{
  protected:
    int fromPort_var;
    int toPort_var;

  private:
    void copy(const XbarMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const XbarMsg&);

  public:
    XbarMsg(const char *name=NULL, int kind=0);
    XbarMsg(const XbarMsg& other);
    virtual ~XbarMsg();
    XbarMsg& operator=(const XbarMsg& other);
    virtual XbarMsg *dup() const {return new XbarMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getFromPort() const;
    virtual void setFromPort(int fromPort);
    virtual int getToPort() const;
    virtual void setToPort(int toPort);
};

inline void doPacking(cCommBuffer *b, XbarMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, XbarMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet ArbiterRequestMsg extends RouterCntrlMsg {
 *  	long dest;  
 *  	long src;
 *  	
 *  	int reqType enum(ElectronicMessageTypes); 
 *  	int portIn;  
 *  	int size; 
 *  	
 *  	long data;
 *  	
 *  	bool bcast;
 *  	int stage = 0;  
 *  
 * }
 * </pre>
 */
class ArbiterRequestMsg : public ::RouterCntrlMsg
{
  protected:
    long dest_var;
    long src_var;
    int reqType_var;
    int portIn_var;
    int size_var;
    long data_var;
    bool bcast_var;
    int stage_var;

  private:
    void copy(const ArbiterRequestMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ArbiterRequestMsg&);

  public:
    ArbiterRequestMsg(const char *name=NULL, int kind=0);
    ArbiterRequestMsg(const ArbiterRequestMsg& other);
    virtual ~ArbiterRequestMsg();
    ArbiterRequestMsg& operator=(const ArbiterRequestMsg& other);
    virtual ArbiterRequestMsg *dup() const {return new ArbiterRequestMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual long getDest() const;
    virtual void setDest(long dest);
    virtual long getSrc() const;
    virtual void setSrc(long src);
    virtual int getReqType() const;
    virtual void setReqType(int reqType);
    virtual int getPortIn() const;
    virtual void setPortIn(int portIn);
    virtual int getSize() const;
    virtual void setSize(int size);
    virtual long getData() const;
    virtual void setData(long data);
    virtual bool getBcast() const;
    virtual void setBcast(bool bcast);
    virtual int getStage() const;
    virtual void setStage(int stage);
};

inline void doPacking(cCommBuffer *b, ArbiterRequestMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ArbiterRequestMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet ElementControlMessage extends RouterCntrlMsg{
 *  	int state enum(PSE_STATE);
 *  	int PSEid;   
 * }
 * </pre>
 */
class ElementControlMessage : public ::RouterCntrlMsg
{
  protected:
    int state_var;
    int PSEid_var;

  private:
    void copy(const ElementControlMessage& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const ElementControlMessage&);

  public:
    ElementControlMessage(const char *name=NULL, int kind=0);
    ElementControlMessage(const ElementControlMessage& other);
    virtual ~ElementControlMessage();
    ElementControlMessage& operator=(const ElementControlMessage& other);
    virtual ElementControlMessage *dup() const {return new ElementControlMessage(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getState() const;
    virtual void setState(int state);
    virtual int getPSEid() const;
    virtual void setPSEid(int PSEid);
};

inline void doPacking(cCommBuffer *b, ElementControlMessage& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, ElementControlMessage& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet BufferAckMsg extends ElectronicMessage {
 *  	
 * }
 * </pre>
 */
class BufferAckMsg : public ::ElectronicMessage
{
  protected:

  private:
    void copy(const BufferAckMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const BufferAckMsg&);

  public:
    BufferAckMsg(const char *name=NULL, int kind=0);
    BufferAckMsg(const BufferAckMsg& other);
    virtual ~BufferAckMsg();
    BufferAckMsg& operator=(const BufferAckMsg& other);
    virtual BufferAckMsg *dup() const {return new BufferAckMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
};

inline void doPacking(cCommBuffer *b, BufferAckMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, BufferAckMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet DRAM_CntrlMsg extends ProcessorData {
 *  	int type enum(DRAM_CntrlTypes);
 *  	
 *  	int row;
 *  	int col;
 *  	
 *  	int bank;
 *  	int burst;
 *  	
 *  	bool writeEn;   
 *  	bool lastAccess;
 *  	
 *  	long coreAddr;
 *  	
 *  	simtime_t creationTime;
 *  	
 *  	long data;
 * }
 * </pre>
 */
class DRAM_CntrlMsg : public ::ProcessorData
{
  protected:
    int type_var;
    int row_var;
    int col_var;
    int bank_var;
    int burst_var;
    bool writeEn_var;
    bool lastAccess_var;
    long coreAddr_var;
    simtime_t creationTime_var;
    long data_var;

  private:
    void copy(const DRAM_CntrlMsg& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const DRAM_CntrlMsg&);

  public:
    DRAM_CntrlMsg(const char *name=NULL, int kind=0);
    DRAM_CntrlMsg(const DRAM_CntrlMsg& other);
    virtual ~DRAM_CntrlMsg();
    DRAM_CntrlMsg& operator=(const DRAM_CntrlMsg& other);
    virtual DRAM_CntrlMsg *dup() const {return new DRAM_CntrlMsg(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual int getType() const;
    virtual void setType(int type);
    virtual int getRow() const;
    virtual void setRow(int row);
    virtual int getCol() const;
    virtual void setCol(int col);
    virtual int getBank() const;
    virtual void setBank(int bank);
    virtual int getBurst() const;
    virtual void setBurst(int burst);
    virtual bool getWriteEn() const;
    virtual void setWriteEn(bool writeEn);
    virtual bool getLastAccess() const;
    virtual void setLastAccess(bool lastAccess);
    virtual long getCoreAddr() const;
    virtual void setCoreAddr(long coreAddr);
    virtual simtime_t getCreationTime() const;
    virtual void setCreationTime(simtime_t creationTime);
    virtual long getData() const;
    virtual void setData(long data);
};

inline void doPacking(cCommBuffer *b, DRAM_CntrlMsg& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, DRAM_CntrlMsg& obj) {obj.parsimUnpack(b);}

/**
 * Class generated from <tt>simCore/messages.msg</tt> by opp_msgc.
 * <pre>
 * packet MemoryAccess extends ApplicationData {
 *     
 *  	long addr;
 *  	int dimm;
 *  	int bank = 0;
 *  	
 *  	int accessType enum (MemoryAccessType);
 *  	int threadId;
 *  	int priority;
 *  	
 *  	int accessSize;  
 *  	   
 * }
 * </pre>
 */
class MemoryAccess : public ::ApplicationData
{
  protected:
    long addr_var;
    int dimm_var;
    int bank_var;
    int accessType_var;
    int threadId_var;
    int priority_var;
    int accessSize_var;

  private:
    void copy(const MemoryAccess& other);

  protected:
    // protected and unimplemented operator==(), to prevent accidental usage
    bool operator==(const MemoryAccess&);

  public:
    MemoryAccess(const char *name=NULL, int kind=0);
    MemoryAccess(const MemoryAccess& other);
    virtual ~MemoryAccess();
    MemoryAccess& operator=(const MemoryAccess& other);
    virtual MemoryAccess *dup() const {return new MemoryAccess(*this);}
    virtual void parsimPack(cCommBuffer *b);
    virtual void parsimUnpack(cCommBuffer *b);

    // field getter/setter methods
    virtual long getAddr() const;
    virtual void setAddr(long addr);
    virtual int getDimm() const;
    virtual void setDimm(int dimm);
    virtual int getBank() const;
    virtual void setBank(int bank);
    virtual int getAccessType() const;
    virtual void setAccessType(int accessType);
    virtual int getThreadId() const;
    virtual void setThreadId(int threadId);
    virtual int getPriority() const;
    virtual void setPriority(int priority);
    virtual int getAccessSize() const;
    virtual void setAccessSize(int accessSize);
};

inline void doPacking(cCommBuffer *b, MemoryAccess& obj) {obj.parsimPack(b);}
inline void doUnpacking(cCommBuffer *b, MemoryAccess& obj) {obj.parsimUnpack(b);}


#endif // _MESSAGES_M_H_
